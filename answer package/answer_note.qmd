---
title: "Note"
author: Igarashi Kosuke, Ito Hiroki, Okamura Soyoka
date: 2024-08-19
date-modified: last-modified
format:
  html:
    embed-resources: true
    self-contained: true
execute:
  echo: true
  warning: false
  # eval: false
---

- このドキュメントでは、事前課題の回答を参考に、コードの改善点を4つ紹介します。

- warmup training package/ にこのqmdファイルを保存すると、このドキュメントのコードが回るように設定されています。

```{r}
#| echo: false
# library
library(here)
library(tidyverse)
```

## 1. DRY (Don't repeat yourself) principle [(wiki)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)


::: {.callout-note appearance="simple"}

## Note 1

コード内の繰り返しを極力減らしましょう。そうすることで、コードの可読性がぐっと上がります。繰り返しがあるなと感じたら、短縮する方法を探す癖をつけましょう。インターネットで検索するとと大抵解決方法が出てきます。
:::



```{r}
#| code-fold: true
# preparation
# load data
# semester data 1
df_sem1 <- read.csv(here('01_data/raw/semester_dummy/semester_data_1.csv')) 
# rename columns
cols_sem1 <- df_sem1 |> slice_head(n = 1)
colnames(df_sem1) <- cols_sem1 
# drop first row
df_sem1 <- df_sem1 |> slice(2:n())
```

-   Example: 列の型の変更

-   繰り返しの例: 1

```{r}
df_sem1_1 <- df_sem1
df_sem1_1$unitid <- as.integer(df_sem1$unitid)
df_sem1_1$semester <- as.integer(df_sem1$semester)
df_sem1_1$quarter <- as.integer(df_sem1$quarter)
df_sem1_1$year <- as.integer(df_sem1$year)
```

-   繰り返しの例: 2

```{r}
df_sem1 |> 
  mutate(unitid = as.integer(unitid),
         semester = as.integer(semester),
         quarter = as.integer(quarter),
         year = as.integer(year)) |> 
  head()
```

-   繰り返さない例

::: {.callout-tip appearance="simple"}

## Useful function

複数の列に同じ操作をするなら`across`関数が便利！

:::

-   `everything()`ですべての列を指定し、-instnmでinstnm列の指定を除外しています。

-   指定した列に対して、`,`以降の関数(`as.integer`)を適用します。

```{r}
df_sem1 |> 
  mutate(across(c(everything(), -instnm), as.integer)) |> 
  head()
```

## 2. より頑健な関数を - `ifelse()`と`if_else()`, `rbind()`と`bind_rows()`, `%>%`と`|>`


::: {.callout-note appearance="simple"}

## Note 2

挙動の制限が厳しいものを使い、コーディングミスを減らすことを心がけましょう。

:::


```{r}
#| code-fold: true
# preparation
# load data
# semester data 1
df_sem1 <- read.csv(here('01_data/raw/semester_dummy/semester_data_1.csv')) 
# rename columns
cols_sem1 <- df_sem1 |> slice_head(n = 1)
colnames(df_sem1) <- cols_sem1 
# drop first row
df_sem1 <- df_sem1 |> slice(2:n())
# semester data 2
df_sem2 <- read.csv(here('01_data/raw/semester_dummy/semester_data_2.csv')) 
# rename
colnames(df_sem2) <- colnames(df_sem1)
```

-   Example: データフレームを縦に結合する(`rbind()` vs `bind_rows()`)

    -   `rbind()`ではうまく結合できていますが、bind_rowsではエラーメッセージが出ています。一つ目のデータフレームではunitidの型がcharacterだが、二つ目はunitidの型がintegerであるから結合できないと教えてくれています。`rbind()`では同じ列名の列を結合する際に、列の型が異なっていても結合できますが、bind_rowsでは結合できません。

    -   この例の場合は、unitidの列に同じ定義の変数が入っているので問題ないのですが、もしunitidに異なる定義の変数が入っていたら（例えば、一つ目のデータフレームではunitidがaaaa'unitid'といったような定義になっている）、その後の分析で困ることが予想されます。`bind_rows()`では、コードを書く人が誤ってデータフレームを結合してしまうことを防いでくれます。

```{r}
#| error: true
rbind(df_sem1, df_sem2) |> head() |> print()
bind_rows(df_sem1, df_sem2)
```

- `ifelse()`と`if_else()`, `%>%`と`|>`の違いも調べてみましょう

## 3. `group_by`の罠

::: {.callout-note appearance="simple"}

## Note 3

`group_by()`を使った後は、`ungroup()`!!

:::


-   `group_by()`の後に`ungroup()`をせず、進めてしまうと、自分が意図しない挙動をすることがあります。

-   以下の例では、unitidごとで`group_by()`をして、unitidごとに最小の年を抽出した後に、すべてのobservationに対して、idを割り当てようとしています。

-   unitidごとに`group_by()`して最小の年を抽出したのち、`ungroup()`せず、列ナンバーを格納する列を作成したときと、`ungroup()`したときの結果を比較すると、

    -   `ungroup()`をしていない場合、unitidごとに1から始まるナンバーが格納されていることがわかります。これは、`ungroup()`をしていないため、`group_by()`以降の処理にグループ化が適応されているからです。
    -   `ungroup()`をした場合、全体で1から始まるナンバーが格納されていることがわかります。

```{r}
df_tmp <- df_sem1[sample(1:nrow(df_sem1), 1000, replace=F),] |>  # restrict sample to reduce the number of rows
  arrange(unitid, year) |> 
  select(unitid, semester, year) |> 
  group_by(unitid) |> 
  mutate(min_year = min(year))
# ungroup()なし
df_tmp |> 
  mutate(n = row_number()) |> 
  head(10)
# ungroup()あり
df_tmp |> 
  ungroup() |> 
  mutate(n = row_number()) |> 
  head(10)
```

::: {.callout-tip appearance="simple"}

## Useful option

`mutate()`, `summarise()`では、optionで `.by =` を指定することで、グループ化して処理をしてくれます。コードがすっきりしますし、`ungroup()`を忘れる心配もないので、こちらを使うことをおすすめします。

:::

```{r}
df_tmp <- df_tmp |> ungroup()
df_tmp |>
  mutate(min_year = min(year), .by = unitid) |> 
  head(10)
```


## 4. あなたのファイル見つかりませんよ？ - `here`パッケージの活用

::: {.callout-note appearance="simple"}

## Note 4

ファイルを読み込む時には`here()`を使おう!!

:::

- 相手から共有されたコードが動かなかった経験はありませんか？その原因は、pathの違いによるものかもしれません。

- (ざっくり書くと)pathとはパソコン内の住所のようなものです。そして、ファイルを読み込む際には、必ずファイルのpath(住所)を指定する必要があります。

- 以下の例では、典型的な`setwd()`を使ったファイルの読み込みの例です。このコードは、自分の環境では動くかもしれませんが、相手の環境では動かない可能性が高いです。

```{r}
#| eval: false
# Set working directory
setwd("C:/Users/USERNAME/Desktop/warmup training package")
# load data
df_sem1 <- read.csv('/01_data/raw/semester_dummy/semester_data_1.csv')
```

- 原因は、相手のパソコンには、C:/Users/USERNAME/Desktopというフォルダが存在しないためです。

- 解決法としては、warmup training packageフォルダの住所を、各PCごとに特定することです。その時に、役立つのが`here()`関数です。


### `here()`の使い方

1. **プロジェクトの起点となるフォルダを開く。  **
2. **`library(here)`を実行する。  **

- 例えば、現在のディレクトリが、C:/Users/USERNAME/Desktop/warmup training packageの状態で`library(here)`を実行すると、以下のように表示されます。

<p style="text-align: center;">here() starts at C:/Users/USERNAME/Desktop/warmup training package</p>


3. **`here()`を使ってファイルを読み込む。**

- この時、`here()`を使ってファイルを読み込むと、以下のように、プロジェクトまでのpathを補完してくれます。

```{r}
#| eval: false
print(here('01_data/raw/semester_dummy/semester_data_1.csv'))
```

"C:/Users/USERNAME/Desktop/warmup training package/01_data/raw/semester_dummy/semester_  
data_1.csv"

```{r}
# load data
# semester data 1
df_sem1 <- read.csv(here('01_data/raw/semester_dummy/semester_data_1.csv'))
# or 
df_sem1 <- read.csv(here('01_data', 'raw', 'semester_dummy', 'semester_data_1.csv'))

```

## 5. コードは他者へのお便り - コメントをうまく活用しよう

::: {.callout-note appearance="simple"}

## Note 5

コードは、読み手へ、自分が何をやったのかを伝えるツールです。コードを書く際には、他者が最速で理解できるようコメントを効果的に使用しましょう。

:::

- コードを見たら一目でわかるようなことについてまで、書く必要はありません。コードに対して補完的にコメントを付けることで読みやすいコードができます。


- コメントなし

```{r}
df_sem1 <- read.csv(here('01_data/raw/semester_dummy/semester_data_1.csv')) 
cols_sem1 <- df_sem1 |> slice_head(n = 1)
colnames(df_sem1) <- cols_sem1 
df_sem1 <- df_sem1 |> slice(2:n())
```

- コメントあり

```{r}
df_sem1 <- read.csv(here('01_data/raw/semester_dummy/semester_data_1.csv')) 
# first row is column names
cols_sem1 <- df_sem1 |> slice_head(n = 1)
colnames(df_sem1) <- cols_sem1 
# drop first row
df_sem1 <- df_sem1 |> slice(2:n())
```

-----

References

- Wikipedia contributors. Don't repeat yourself. In Wikipedia, The Free Encyclopedia. Retrieved August 17, 2024, from https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
